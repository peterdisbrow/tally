<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tally Mock Lab</title>
  <style>
    :root {
      --bg: #07110d;
      --bg-2: #0d1e17;
      --card: rgba(15, 27, 22, 0.78);
      --line: rgba(100, 170, 135, 0.28);
      --text: #ebf5ef;
      --muted: #9bb7aa;
      --green: #4ade80;
      --cyan: #60a5fa;
      --warn: #facc15;
      --danger: #fb7185;
      --mono: "SF Mono", "Menlo", monospace;
      --font: "Avenir Next", "Segoe UI", sans-serif;
      --drag-height: 36px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--text);
      font-family: var(--font);
      background:
        radial-gradient(circle at 0% 0%, rgba(74, 222, 128, 0.2), transparent 42%),
        radial-gradient(circle at 100% 0%, rgba(96, 165, 250, 0.16), transparent 40%),
        linear-gradient(145deg, var(--bg), var(--bg-2));
      min-height: 100vh;
      padding: calc(var(--drag-height) + 14px + env(safe-area-inset-top)) 18px 18px;
    }

    .window-drag-strip {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: calc(var(--drag-height) + env(safe-area-inset-top));
      -webkit-app-region: drag;
      z-index: 120;
      border-bottom: 1px solid var(--line);
      background:
        linear-gradient(to bottom, rgba(12, 24, 20, 0.9), rgba(12, 24, 20, 0.55));
      backdrop-filter: blur(4px);
    }

    .wrap { max-width: 1320px; margin: 0 auto; }

    .hero {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: linear-gradient(120deg, rgba(12, 28, 22, 0.86), rgba(13, 22, 30, 0.74));
      padding: 14px 16px;
      box-shadow: 0 12px 34px rgba(0, 0, 0, 0.34);
      margin-bottom: 14px;
    }

    .hero h1 {
      margin: 0;
      font-size: 30px;
      letter-spacing: -0.03em;
    }

    .hero p {
      margin: 6px 0 10px;
      color: var(--muted);
      font-size: 13px;
    }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; }

    .status-line {
      margin-top: 10px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
      line-height: 1.4;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }

    .card {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: var(--card);
      padding: 10px;
      backdrop-filter: blur(4px);
    }

    .wide { grid-column: 1 / -1; }

    .card h2 {
      margin: 0 0 8px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--green);
      font-family: var(--mono);
    }

    .row { display: flex; gap: 6px; align-items: center; margin-bottom: 6px; flex-wrap: wrap; }
    .row:last-child { margin-bottom: 0; }

    .row label {
      min-width: 112px;
      font-size: 11px;
      font-family: var(--mono);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .endpoint {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
      word-break: break-word;
      line-height: 1.4;
      margin-bottom: 4px;
    }

    input, select, button {
      border-radius: 7px;
      border: 1px solid var(--line);
      background: rgba(4, 10, 9, 0.9);
      color: var(--text);
      font-size: 12px;
      padding: 7px 8px;
      font-family: var(--font);
    }

    input, select {
      min-width: 0;
      flex: 1;
      font-family: var(--mono);
    }

    input.port {
      max-width: 92px;
      flex: 0 0 92px;
    }

    button {
      cursor: pointer;
      font-weight: 700;
      background: linear-gradient(145deg, rgba(74, 222, 128, 0.26), rgba(74, 222, 128, 0.1));
    }

    button.alt {
      background: linear-gradient(145deg, rgba(96, 165, 250, 0.24), rgba(96, 165, 250, 0.08));
    }

    button.warn {
      background: linear-gradient(145deg, rgba(250, 204, 21, 0.25), rgba(250, 204, 21, 0.08));
      color: #fef08a;
    }

    button.danger {
      background: linear-gradient(145deg, rgba(251, 113, 133, 0.27), rgba(251, 113, 133, 0.1));
      color: #fecdd3;
    }

    .checks {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      margin-top: 8px;
    }

    .check {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      color: var(--muted);
      font-size: 11px;
      font-family: var(--mono);
    }

    .check input {
      width: auto;
      flex: none;
      accent-color: var(--green);
    }

    pre {
      margin: 0;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(6, 11, 9, 0.9);
      padding: 12px;
      font-family: var(--mono);
      font-size: 11px;
      color: #d9ede2;
      max-height: 280px;
      overflow: auto;
    }

    .pre-tall { max-height: 340px; }

    .footer {
      margin-top: 8px;
      font-size: 11px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .badge {
      display: inline-block;
      border-radius: 999px;
      border: 1px solid var(--line);
      padding: 3px 8px;
      font-family: var(--mono);
      font-size: 10px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--muted);
      margin-left: 8px;
    }

    .changes-panel {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(6, 11, 9, 0.9);
      max-height: 300px;
      overflow: auto;
      padding: 8px;
    }

    .change-row {
      border: 1px solid rgba(100, 170, 135, 0.2);
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 7px;
      background: rgba(11, 19, 16, 0.7);
    }

    .change-row:last-child { margin-bottom: 0; }

    .change-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 5px;
      font-family: var(--mono);
      font-size: 11px;
    }

    .change-path {
      color: var(--cyan);
      word-break: break-all;
      line-height: 1.4;
    }

    .change-time {
      color: var(--muted);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .change-values {
      display: grid;
      grid-template-columns: 1fr;
      gap: 4px;
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text);
      line-height: 1.35;
    }

    .change-values .before { color: #fca5a5; }
    .change-values .after { color: #86efac; }

    .change-summary {
      margin-bottom: 8px;
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }

    .change-empty {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      padding: 6px 4px;
    }

    .device-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }

    .device-tab-btn {
      padding: 6px 10px;
      font-size: 11px;
      font-family: var(--mono);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      background: rgba(6, 11, 9, 0.65);
      border: 1px solid var(--line);
      color: var(--muted);
    }

    .device-tab-btn.active {
      color: var(--text);
      border-color: rgba(74, 222, 128, 0.55);
      background: linear-gradient(145deg, rgba(74, 222, 128, 0.32), rgba(74, 222, 128, 0.14));
    }

    .device-panel {
      display: none;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: rgba(6, 11, 9, 0.75);
      position: relative;
    }

    .device-panel.active {
      display: block;
    }

    #tab-panel-atem {
      min-height: 520px;
      padding-top: 190px;
    }

    .atem-live-pad {
      position: absolute;
      top: 10px;
      left: 10px;
      width: min(620px, calc(100% - 20px));
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(3, 9, 8, 0.92);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.33);
      z-index: 2;
    }

    .atem-live-handle {
      border-bottom: 1px solid var(--line);
      padding: 6px 10px;
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      cursor: grab;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .atem-live-handle:active { cursor: grabbing; }

    .atem-live-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
      padding: 8px;
    }

    .atem-live-cell {
      border: 1px solid rgba(100, 170, 135, 0.22);
      border-radius: 8px;
      background: rgba(9, 20, 16, 0.84);
      padding: 8px;
      min-height: 58px;
    }

    .atem-live-k {
      font-family: var(--mono);
      color: var(--muted);
      font-size: 10px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .atem-live-v {
      margin-top: 5px;
      font-size: 17px;
      font-weight: 700;
    }

    .atem-live-v.program { color: #86efac; }
    .atem-live-v.preview { color: #93c5fd; }
    .atem-live-v.warn { color: #fde68a; font-size: 12px; font-family: var(--mono); }

    .atem-live-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      padding: 0 8px 8px;
    }

    .mini-check {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 8px;
      border: 1px solid var(--line);
      border-radius: 7px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      background: rgba(8, 15, 12, 0.8);
    }

    .mini-check input {
      width: auto;
      min-width: 0;
      flex: none;
      accent-color: var(--green);
      margin: 0;
      padding: 0;
    }

    .atem-console {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }

    .atem-panel-card {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(5, 12, 10, 0.84);
      padding: 8px;
    }

    .atem-panel-title {
      margin: 0 0 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--muted);
      font-family: var(--mono);
    }

    .atem-bus-row {
      display: grid;
      grid-template-columns: 80px 1fr;
      gap: 7px;
      align-items: start;
      margin-bottom: 7px;
    }

    .atem-bus-row:last-child { margin-bottom: 0; }

    .atem-bus-label {
      border-radius: 8px;
      border: 1px solid var(--line);
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      text-align: center;
      padding: 8px 6px;
      color: var(--muted);
      background: rgba(8, 15, 12, 0.8);
    }

    .atem-bus-label.program {
      border-color: rgba(248, 113, 113, 0.5);
      color: #fecaca;
      background: rgba(127, 29, 29, 0.26);
    }

    .atem-bus-label.preview {
      border-color: rgba(74, 222, 128, 0.5);
      color: #bbf7d0;
      background: rgba(20, 83, 45, 0.28);
    }

    .atem-bus-grid {
      display: grid;
      grid-template-columns: repeat(10, minmax(0, 1fr));
      gap: 5px;
    }

    .atem-src-btn {
      border-radius: 8px;
      border: 1px solid rgba(100, 170, 135, 0.24);
      background: rgba(4, 10, 9, 0.95);
      color: var(--text);
      padding: 5px 4px;
      text-align: left;
      min-height: 44px;
    }

    .atem-src-btn.program-active {
      border-color: rgba(248, 113, 113, 0.62);
      background: linear-gradient(145deg, rgba(248, 113, 113, 0.32), rgba(248, 113, 113, 0.12));
      color: #ffe4e6;
    }

    .atem-src-btn.preview-active {
      border-color: rgba(74, 222, 128, 0.62);
      background: linear-gradient(145deg, rgba(74, 222, 128, 0.32), rgba(74, 222, 128, 0.12));
      color: #dcfce7;
    }

    .atem-src-btn .num {
      display: block;
      font-family: var(--mono);
      font-size: 10px;
      letter-spacing: 0.04em;
      opacity: 0.9;
    }

    .atem-src-btn .name {
      display: block;
      margin-top: 2px;
      font-size: 10px;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.95;
    }

    .atem-trans-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .atem-trans-grid .full {
      grid-column: 1 / -1;
    }

    .atem-chip {
      border-radius: 8px;
      border: 1px solid var(--line);
      background: rgba(8, 16, 13, 0.84);
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      padding: 6px 8px;
    }

    .atem-live-pad.program-pulse {
      box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.55), 0 10px 24px rgba(0, 0, 0, 0.33);
    }

    .atem-live-pad.preview-pulse {
      box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.55), 0 10px 24px rgba(0, 0, 0, 0.33);
    }

    @media (max-width: 1120px) {
      .atem-console {
        grid-template-columns: 1fr;
      }

      .atem-bus-grid {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    }

    .x32-console {
      display: grid;
      grid-template-columns: 1.7fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }

    .x32-panel-card {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(5, 12, 10, 0.84);
      padding: 8px;
    }

    .x32-panel-title {
      margin: 0 0 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--muted);
      font-family: var(--mono);
    }

    .x32-bank-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .x32-bank-row button.active {
      border-color: rgba(250, 204, 21, 0.65);
      color: #fef08a;
      background: linear-gradient(145deg, rgba(250, 204, 21, 0.25), rgba(250, 204, 21, 0.08));
    }

    .x32-strip-grid {
      display: grid;
      grid-template-columns: repeat(8, minmax(0, 1fr));
      gap: 6px;
    }

    .x32-strip {
      border: 1px solid rgba(100, 170, 135, 0.25);
      border-radius: 8px;
      padding: 6px 5px;
      background: rgba(6, 11, 9, 0.92);
      min-width: 0;
    }

    .x32-strip.selected {
      border-color: rgba(96, 165, 250, 0.62);
      box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.45) inset;
    }

    .x32-strip-head {
      font-family: var(--mono);
      font-size: 10px;
      color: var(--muted);
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
      gap: 4px;
    }

    .x32-strip-name {
      font-size: 10px;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 5px;
      min-height: 14px;
    }

    .x32-meter-wrap {
      border: 1px solid var(--line);
      border-radius: 6px;
      height: 62px;
      background: rgba(3, 8, 7, 0.95);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3px;
      padding: 3px;
      margin-bottom: 5px;
    }

    .x32-meter-col {
      border-radius: 4px;
      background: rgba(12, 25, 19, 0.95);
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(100, 170, 135, 0.22);
    }

    .x32-meter-fill {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 0%;
      background: linear-gradient(180deg, #f87171 0%, #facc15 36%, #4ade80 100%);
      transition: height 120ms linear;
    }

    .x32-fader {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      height: 110px;
      margin: 0 auto;
      display: block;
    }

    .x32-value {
      font-family: var(--mono);
      font-size: 10px;
      color: var(--muted);
      text-align: center;
      margin: 4px 0;
    }

    .x32-mini-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
    }

    .x32-mini-actions button {
      padding: 5px 4px;
      font-size: 10px;
    }

    .x32-mini-actions button.active {
      border-color: rgba(251, 113, 133, 0.65);
      background: linear-gradient(145deg, rgba(251, 113, 133, 0.35), rgba(251, 113, 133, 0.14));
      color: #ffe4e6;
    }

    .x32-mini-actions button.solo-active {
      border-color: rgba(250, 204, 21, 0.65);
      background: linear-gradient(145deg, rgba(250, 204, 21, 0.35), rgba(250, 204, 21, 0.14));
      color: #fef08a;
    }

    .x32-master-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-bottom: 6px;
    }

    .x32-master-row .full {
      grid-column: 1 / -1;
    }

    .x32-live-pad {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(3, 9, 8, 0.92);
      margin-bottom: 8px;
    }

    .x32-live-handle {
      border-bottom: 1px solid var(--line);
      padding: 6px 10px;
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      cursor: grab;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .x32-live-handle:active { cursor: grabbing; }

    .x32-live-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
      padding: 8px;
    }

    .x32-live-cell {
      border: 1px solid rgba(100, 170, 135, 0.22);
      border-radius: 8px;
      background: rgba(9, 20, 16, 0.84);
      padding: 8px;
      min-height: 56px;
    }

    .x32-live-k {
      font-family: var(--mono);
      color: var(--muted);
      font-size: 10px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .x32-live-v {
      margin-top: 5px;
      font-size: 15px;
      font-weight: 700;
      color: var(--text);
    }

    #tab-panel-x32 {
      min-height: 510px;
      padding-top: 205px;
      position: relative;
    }

    #x32-live-pad {
      position: absolute;
      top: 10px;
      left: 10px;
      width: min(640px, calc(100% - 20px));
      z-index: 2;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.33);
    }

    @media (max-width: 1120px) {
      .x32-console {
        grid-template-columns: 1fr;
      }
      .x32-strip-grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
      .x32-live-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="window-drag-strip" aria-hidden="true"></div>

  <div class="wrap">
    <section class="hero">
      <h1>Tally Mock Lab <span class="badge">Standalone</span></h1>
      <p>Independent multi-device simulator for API command testing. Configure device IPs, launch, then drive state through the control API.</p>
      <div class="actions">
        <button onclick="startLab()">Launch Lab</button>
        <button class="alt" onclick="stopLab()">Stop Lab</button>
        <button class="alt" onclick="openControlApi()">Open Control API</button>
        <button class="warn" onclick="refreshStatus()">Refresh</button>
      </div>
      <div id="status" class="status-line">Loading...</div>
    </section>

    <section class="grid">
      <article class="card">
        <h2>Network Layout</h2>
        <div class="row">
          <label>NIC</label>
          <select id="cfg-nic"></select>
          <button class="alt" onclick="applyNicPreset()">Apply NIC Subnet</button>
        </div>
        <div class="row">
          <label>Unique IP Alias</label>
          <button class="alt" onclick="setupUniqueAliases()">Setup on NIC</button>
          <button class="warn" onclick="removeUniqueAliases()">Remove from NIC</button>
        </div>
        <pre id="alias-commands">(alias commands appear here after setup/remove)</pre>
        <div class="row"><label>ATEM</label><input id="cfg-atem-ip" type="text"><input id="cfg-atem-port" class="port" type="number" min="1" max="65535"></div>
        <div class="row"><label>OBS</label><input id="cfg-obs-ip" type="text"><input id="cfg-obs-port" class="port" type="number" min="1" max="65535"></div>
        <div class="row"><label>X32</label><input id="cfg-x32-ip" type="text"><input id="cfg-x32-port" class="port" type="number" min="1" max="65535"></div>
        <div class="row"><label>Encoder</label><input id="cfg-encoder-ip" type="text"><input id="cfg-encoder-port" class="port" type="number" min="1" max="65535"></div>
        <div class="row"><label>HyperDeck</label><input id="cfg-hyperdeck-ip" type="text"><input id="cfg-hyperdeck-port" class="port" type="number" min="1" max="65535"></div>
        <div class="row"><label>ProPresenter</label><input id="cfg-propresenter-ip" type="text"><input id="cfg-propresenter-port" class="port" type="number" min="1" max="65535"></div>
        <div class="row"><label>Control API</label><input id="cfg-controlApi-ip" type="text"><input id="cfg-controlApi-port" class="port" type="number" min="1" max="65535"></div>

        <div class="checks">
          <label class="check"><input id="cfg-unique-ips" type="checkbox">Require unique IP for each device</label>
          <label class="check"><input id="cfg-allow-fallback" type="checkbox">Allow fallback if IP cannot bind</label>
        </div>

        <div class="row" style="margin-top:10px;">
          <button onclick="saveConfig()">Save Config</button>
          <button class="alt" onclick="loadConfig()">Reload Config</button>
        </div>
      </article>

      <article class="card">
        <h2>Active Endpoints</h2>
        <div class="endpoint" id="ep-atem">ATEM: -</div>
        <div class="endpoint" id="ep-obs">OBS: -</div>
        <div class="endpoint" id="ep-x32">X32: -</div>
        <div class="endpoint" id="ep-encoder">Encoder: -</div>
        <div class="endpoint" id="ep-hyperdeck">HyperDeck: -</div>
        <div class="endpoint" id="ep-propresenter">ProPresenter: -</div>
        <div class="endpoint" id="ep-control" style="margin-top:7px;color:var(--cyan);">Control API: -</div>
      </article>

      <article class="card wide">
        <div class="row" style="justify-content: space-between; margin-bottom:8px;">
          <h2 style="margin:0;">Combined State</h2>
          <button class="danger" onclick="resetAll()">Reset All</button>
        </div>
        <pre id="state-json" class="pre-tall">{}</pre>
      </article>

      <article class="card wide">
        <div class="row" style="justify-content: space-between; margin-bottom:8px;">
          <h2 style="margin:0;">Live Changes</h2>
          <div class="actions">
            <button class="alt" id="btn-change-pause" onclick="toggleChangeFeed()">Pause Feed</button>
            <button class="warn" onclick="clearChangeFeed()">Clear</button>
          </div>
        </div>
        <div id="change-summary" class="change-summary">Waiting for state updates...</div>
        <div id="change-list" class="changes-panel">
          <div class="change-empty">No changes detected yet.</div>
        </div>
      </article>

      <article class="card">
        <div class="row" style="justify-content: space-between; margin-bottom:8px;">
          <h2 style="margin:0;">Command Catalog</h2>
          <button class="alt" onclick="loadCommands()">Load Commands</button>
        </div>
        <pre id="commands-json">[]</pre>
      </article>

      <article class="card">
        <h2>Mock Lab Logs</h2>
        <pre id="logs-json">(waiting for logs)</pre>
      </article>

      <article class="card wide">
        <div class="row" style="justify-content: space-between; margin-bottom:8px;">
          <h2 style="margin:0;">Device Console</h2>
          <div class="change-summary" style="margin:0;">Switch tabs to control each mock device.</div>
        </div>

        <div class="device-tabs">
          <button class="device-tab-btn active" id="tab-btn-atem" onclick="switchDeviceTab('atem')">ATEM</button>
          <button class="device-tab-btn" id="tab-btn-hyperdeck" onclick="switchDeviceTab('hyperdeck')">HyperDeck</button>
          <button class="device-tab-btn" id="tab-btn-obs" onclick="switchDeviceTab('obs')">OBS + Encoder</button>
          <button class="device-tab-btn" id="tab-btn-x32" onclick="switchDeviceTab('x32')">X32 Mixer</button>
          <button class="device-tab-btn" id="tab-btn-propresenter" onclick="switchDeviceTab('propresenter')">ProPresenter</button>
        </div>

        <div class="device-panel active" id="tab-panel-atem">
          <div class="atem-live-pad" id="atem-live-pad">
            <div class="atem-live-handle" id="atem-live-handle">
              <span>ATEM Live Pad (drag)</span>
              <span id="atem-live-last-action">Ready</span>
            </div>
            <div class="atem-live-grid">
              <div class="atem-live-cell"><div class="atem-live-k">Program</div><div id="atem-live-program" class="atem-live-v program">-</div></div>
              <div class="atem-live-cell"><div class="atem-live-k">Preview</div><div id="atem-live-preview" class="atem-live-v preview">-</div></div>
              <div class="atem-live-cell"><div class="atem-live-k">Transition</div><div id="atem-live-transition" class="atem-live-v">mix @ 25</div></div>
              <div class="atem-live-cell"><div class="atem-live-k">Status</div><div id="atem-live-status" class="atem-live-v warn">idle</div></div>
            </div>
            <div class="atem-live-actions">
              <button onclick="atemCut()">Cut</button>
              <button class="alt" onclick="atemAuto()">Auto</button>
              <button class="alt" onclick="atemRec(true)">Rec On</button>
              <button class="alt" onclick="atemRec(false)">Rec Off</button>
            </div>
          </div>

          <div class="atem-console">
            <div class="atem-panel-card">
              <h3 class="atem-panel-title">M/E Bus</h3>
              <div class="atem-bus-row">
                <div class="atem-bus-label program">Program</div>
                <div id="atem-program-bus" class="atem-bus-grid"></div>
              </div>
              <div class="atem-bus-row">
                <div class="atem-bus-label preview">Preview</div>
                <div id="atem-preview-bus" class="atem-bus-grid"></div>
              </div>
            </div>
            <div class="atem-panel-card">
              <h3 class="atem-panel-title">Transition Control</h3>
              <div class="atem-trans-grid">
                <input id="atem-program" type="number" min="1" value="1">
                <input id="atem-preview" type="number" min="1" value="2">
                <button onclick="atemProgram()">Take Program</button>
                <button class="alt" onclick="atemPreview()">Set Preview</button>
                <select id="atem-trans-style" class="full"><option value="mix">Mix</option><option value="dip">Dip</option><option value="wipe">Wipe</option><option value="dve">DVE</option><option value="sting">Sting</option></select>
                <input id="atem-trans-rate" type="number" min="1" max="250" value="25">
                <button onclick="atemTransition()">Apply Rate/Style</button>
                <div class="atem-chip">PGM <span id="atem-chip-pgm">1</span> | PVW <span id="atem-chip-pvw">2</span></div>
                <button onclick="atemCut()">Cut</button>
                <button class="alt" onclick="atemAuto()">Auto</button>
                <button class="alt" onclick="atemFade(true)">FTB On</button>
                <button class="warn" onclick="atemFade(false)">FTB Off</button>
                <input id="atem-tbar" class="full" type="range" min="0" max="100" value="0" oninput="atemTbarPreview()">
                <div id="atem-tbar-readout" class="atem-chip full">T-Bar parked at preview (0%)</div>
              </div>
            </div>
          </div>

          <div class="row"><input id="atem-aux-bus" type="number" min="1" value="1"><input id="atem-aux-input" type="number" min="1" value="1"><button onclick="atemAux()">Set Aux</button></div>
          <div class="row"><input id="atem-usk-keyer" type="number" min="0" value="0"><select id="atem-usk-type"><option value="luma">Luma</option><option value="chroma">Chroma</option><option value="pattern">Pattern</option><option value="dve">DVE</option></select><button onclick="atemUskType()">USK Type</button><button class="alt" onclick="atemUskOnAir(true)">USK On</button><button class="alt" onclick="atemUskOnAir(false)">USK Off</button><button class="warn" onclick="atemUskTie()">USK Tie</button></div>
          <div class="row"><input id="atem-usk-fill" type="number" min="1" value="3"><input id="atem-usk-key" type="number" min="1" value="4"><button onclick="atemUskSources()">USK Sources</button></div>
          <div class="row"><input id="atem-dsk-keyer" type="number" min="0" value="0"><input id="atem-dsk-rate" type="number" min="1" max="250" value="25"><button onclick="atemDskRate()">DSK Rate</button><button class="alt" onclick="atemDskOnAir(true)">DSK On</button><button class="alt" onclick="atemDskOnAir(false)">DSK Off</button><button class="warn" onclick="atemDskTie()">DSK Tie</button></div>
          <div class="row"><input id="atem-dsk-fill" type="number" min="1" value="3"><input id="atem-dsk-key" type="number" min="1" value="4"><button onclick="atemDskSource()">DSK Sources</button></div>
          <div class="row"><input id="atem-ss-box" type="number" min="0" max="3" value="0"><input id="atem-ss-input" type="number" min="1" value="1"><input id="atem-ss-x" type="number" min="-1" max="1" step="0.05" value="0"><input id="atem-ss-y" type="number" min="-1" max="1" step="0.05" value="0"><input id="atem-ss-size" type="number" min="0.05" max="1" step="0.05" value="0.5"><label class="mini-check"><input id="atem-ss-cropped" type="checkbox">Cropped</label><button onclick="atemSuperSourceBox(true)">SS Box On</button><button class="alt" onclick="atemSuperSourceBox(false)">SS Box Off</button></div>
          <div class="row"><input id="atem-ss-fill" type="number" min="1" value="1"><input id="atem-ss-cut" type="number" min="1" value="2"><input id="atem-ss-clip" type="number" min="0" max="1000" value="0"><input id="atem-ss-gain" type="number" min="0" max="1000" value="0"><label class="mini-check"><input id="atem-ss-premultiplied" type="checkbox">Premult</label><label class="mini-check"><input id="atem-ss-invert" type="checkbox">Invert</label><button onclick="atemSuperSourceArt(true)">SS Art On</button><button class="alt" onclick="atemSuperSourceArt(false)">SS Art Off</button></div>
          <div class="row"><input id="atem-color-index" type="number" min="1" max="2" value="1"><input id="atem-color-hue" type="number" min="0" max="359" value="0"><input id="atem-color-saturation" type="number" min="0" max="1000" value="0"><input id="atem-color-luma" type="number" min="0" max="1000" value="0"><button onclick="atemColor()">Set Color Gen</button></div>
          <div class="row"><input id="atem-macro-index" type="number" min="0" value="1"><button onclick="atemMacroRun()">Run Macro</button><button class="danger" onclick="atemMacroStop()">Stop Macro</button></div>
          <div class="row"><input id="atem-media-player" type="number" min="1" value="1"><select id="atem-media-type"><option value="still">Still</option><option value="clip">Clip</option></select><input id="atem-media-index" type="number" min="1" value="1"><button onclick="atemMediaSource()">Set Media Source</button><button class="alt" onclick="atemMediaPlay(true)">Play</button><button class="alt" onclick="atemMediaPlay(false)">Stop</button></div>
          <div class="row"><input id="atem-label-input" type="number" min="1" value="1"><input id="atem-label-name" value="Center Cam"><input id="atem-label-short" value="CTR"><button onclick="atemLabel()">Set Label</button></div>
          <div class="row"><input id="atem-ptz-camera" type="number" min="1" value="1"><input id="atem-ptz-preset" type="number" min="1" value="2"><button onclick="atemPtzPreset()">Recall Preset</button><input id="atem-ptz-pan" type="number" min="-1" max="1" step="0.1" value="0"><input id="atem-ptz-tilt" type="number" min="-1" max="1" step="0.1" value="0"><button class="alt" onclick="atemPtzPanTilt()">Pan/Tilt</button><input id="atem-ptz-zoom" type="number" min="-1" max="1" step="0.1" value="0"><button class="alt" onclick="atemPtzZoom()">Zoom</button></div>
        </div>

        <div class="device-panel" id="tab-panel-hyperdeck">
          <div class="row"><input id="hd-index" type="number" min="0" value="0"><select id="hd-action"><option value="play">Play</option><option value="stop">Stop</option><option value="record">Record</option><option value="next">Next</option><option value="prev">Prev</option></select><button onclick="hyperdeckAction()">Run Action</button></div>
        </div>

        <div class="device-panel" id="tab-panel-obs">
          <div class="row"><button onclick="obsStream(true)">Stream On</button><button class="alt" onclick="obsStream(false)">Stream Off</button><button onclick="obsRecord(true)">Record On</button><button class="alt" onclick="obsRecord(false)">Record Off</button></div>
          <div class="row"><input id="obs-scene" value="Program"><button onclick="obsScene()">Set Scene</button></div>
          <div class="row"><input id="enc-fps" type="number" min="1" max="120" value="30"><input id="enc-cpu" type="number" min="0" max="100" value="18"><input id="enc-cong" type="number" min="0" max="1" step="0.01" value="0.02"><input id="enc-kbps" type="number" min="64" value="4500"><button onclick="encoderApply()">Apply Encoder</button></div>
          <div class="row"><input id="obs-mock-title" value="Tally Mock OBS"><input id="obs-mock-subtitle" value="Static Graphic Feed"><input id="obs-mock-fps" type="number" min="1" max="10" value="2"><button onclick="obsMockGraphicApply()">Apply Mock Graphic</button></div>
          <div class="row"><button class="alt" onclick="openObsMockGraphic()">Open Static Graphic</button><button class="alt" onclick="openObsMockStream()">Open Mock Stream</button></div>
          <div class="row"><div id="obs-mock-stream-url" class="endpoint">Mock Stream: -</div></div>
          <div class="row"><div id="obs-mock-graphic-url" class="endpoint">Static Graphic: -</div></div>
          <div class="row"><div id="obs-mock-state" class="change-summary">OBS mock output idle.</div></div>
        </div>

        <div class="device-panel" id="tab-panel-x32">
          <div class="x32-live-pad" id="x32-live-pad">
            <div class="x32-live-handle" id="x32-live-handle">
              <span>X32 Live Pad (drag)</span>
              <span id="x32-live-last-action">Ready</span>
            </div>
            <div class="x32-live-grid">
              <div class="x32-live-cell"><div class="x32-live-k">Selected</div><div id="x32-live-selected" class="x32-live-v">CH 1</div></div>
              <div class="x32-live-cell"><div class="x32-live-k">Scene</div><div id="x32-live-scene" class="x32-live-v">1</div></div>
              <div class="x32-live-cell"><div class="x32-live-k">Main Fader</div><div id="x32-live-main" class="x32-live-v">0.78</div></div>
              <div class="x32-live-cell"><div class="x32-live-k">Main Mute</div><div id="x32-live-main-muted" class="x32-live-v">OFF</div></div>
            </div>
          </div>

          <div class="x32-console">
            <div class="x32-panel-card">
              <h3 class="x32-panel-title">Input Channels</h3>
              <div class="x32-bank-row">
                <button id="x32-bank-1" onclick="x32SetBank(1)">CH 1-8</button>
                <button id="x32-bank-9" class="alt" onclick="x32SetBank(9)">CH 9-16</button>
                <button id="x32-bank-17" class="alt" onclick="x32SetBank(17)">CH 17-24</button>
                <button id="x32-bank-25" class="alt" onclick="x32SetBank(25)">CH 25-32</button>
              </div>
              <div id="x32-strip-grid" class="x32-strip-grid"></div>
            </div>

            <div class="x32-panel-card">
              <h3 class="x32-panel-title">Selected Channel</h3>
              <div class="x32-master-row">
                <input id="x32-selected-channel" type="number" min="1" max="32" value="1">
                <button onclick="x32SelectChannelFromInput()">Select</button>
                <input id="x32-selected-label" class="full" type="text" value="CH 1">
                <button class="full" onclick="x32RenameSelected()">Rename Channel</button>
                <input id="x32-selected-gain" type="number" min="-24" max="24" step="0.5" value="0">
                <button onclick="x32SetSelectedGain()">Set Gain (dB)</button>
                <input id="x32-selected-pan" type="number" min="-1" max="1" step="0.05" value="0">
                <button onclick="x32SetSelectedPan()">Set Pan</button>
                <button id="x32-selected-mute-btn" onclick="x32ToggleSelectedMute()">Mute</button>
                <button id="x32-selected-solo-btn" class="alt" onclick="x32ToggleSelectedSolo()">Solo</button>
                <div class="atem-chip full">Pre Meter: <span id="x32-selected-pre">0%</span> | Post Meter: <span id="x32-selected-post">0%</span></div>
              </div>

              <h3 class="x32-panel-title" style="margin-top:8px;">Main / Scene</h3>
              <div class="x32-master-row">
                <input id="x32-main-fader-slider" type="range" min="0" max="1" step="0.01" value="0.78" oninput="x32MainFaderPreview()" onchange="x32SetMainFader()">
                <div id="x32-main-fader-readout" class="atem-chip">Main: 0.78</div>
                <button onclick="x32Mute(true)">Mute Main</button>
                <button class="alt" onclick="x32Mute(false)">Unmute Main</button>
                <input id="x32-scene" type="number" min="1" value="1">
                <button onclick="x32Scene()">Recall Scene</button>
              </div>
            </div>
          </div>
        </div>

        <div class="device-panel" id="tab-panel-propresenter">
          <div class="row"><button onclick="ppNext()">Next Slide</button><button class="alt" onclick="ppPrev()">Previous Slide</button></div>
          <div class="row"><input id="pp-slide" type="number" min="1" value="1"><button onclick="ppGo()">Go To Slide</button></div>
        </div>
      </article>
    </section>

    <div class="footer">Run this app on a dedicated machine for stable binding and endpoint testing against your command APIs.</div>
  </div>

  <script>
    const api = window.electronAPI;
    const ENDPOINT_KEYS = ['atem', 'obs', 'x32', 'encoder', 'hyperdeck', 'propresenter', 'controlApi'];
    const DEVICE_ONLY_KEYS = ['atem', 'obs', 'x32', 'encoder', 'hyperdeck', 'propresenter'];
    const MAX_CHANGE_EVENTS = 160;
    let mockLab = null;
    let nicList = [];
    let lastFlatState = null;
    let changeFeedPaused = false;
    const changeEvents = [];
    let refreshTicker = null;
    let hiddenChangeCount = 0;
    let autoTbarTimer = null;
    let x32BankStart = 1;

    function byId(id) {
      return document.getElementById(id);
    }

    function setStatus(text) {
      byId('status').textContent = text;
    }

    function endpointText(name, value) {
      const el = byId(name);
      if (el) el.textContent = value;
    }

    function parseNicValue(value) {
      const raw = String(value || '');
      const idx = raw.indexOf('@@');
      if (idx === -1) return { name: raw.trim(), ip: '' };
      return {
        name: raw.slice(0, idx),
        ip: raw.slice(idx + 2),
      };
    }

    function currentNic() {
      const select = byId('cfg-nic');
      if (!select || !select.value) return null;
      const parsed = parseNicValue(select.value);
      if (!parsed.name || !parsed.ip) return null;
      return parsed;
    }

    function currentNicDetails() {
      const nic = currentNic();
      if (!nic) return null;
      const exact = nicList.find((iface) => iface.name === nic.name && iface.ip === nic.ip);
      const byName = nicList.find((iface) => iface.name === nic.name);
      const matched = exact || byName || null;
      return {
        ...nic,
        netmask: matched?.netmask || '255.255.255.0',
      };
    }

    async function hydrateNetworkInterfaces(preferredNicName = '') {
      const select = byId('cfg-nic');
      if (!select) return;

      nicList = await api.getNetworkInterfaces();
      select.innerHTML = '';

      if (!Array.isArray(nicList) || nicList.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No interfaces found';
        select.appendChild(opt);
        return;
      }

      nicList.forEach((iface) => {
        const opt = document.createElement('option');
        opt.value = `${iface.name}@@${iface.ip}`;
        opt.textContent = `${iface.name} (${iface.ip})`;
        select.appendChild(opt);
      });

      const preferred = nicList.find((i) => i.name === preferredNicName) || nicList[0];
      if (preferred) {
        select.value = `${preferred.name}@@${preferred.ip}`;
      }
    }

    function applyNicPreset() {
      const nic = currentNic();
      if (!nic) {
        setStatus('Select a NIC first.');
        return;
      }

      const octets = nic.ip.split('.');
      if (octets.length !== 4) {
        setStatus(`Selected NIC IP is not IPv4: ${nic.ip}`);
        return;
      }

      const requireUniqueIps = !!byId('cfg-unique-ips')?.checked;
      const subnet = `${octets[0]}.${octets[1]}.${octets[2]}`;

      if (requireUniqueIps) {
        const hostMap = {
          atem: 11,
          obs: 12,
          x32: 13,
          encoder: 14,
          hyperdeck: 15,
          propresenter: 16,
        };
        Object.entries(hostMap).forEach(([key, host]) => {
          byId(`cfg-${key}-ip`).value = `${subnet}.${host}`;
        });
      } else {
        ['atem', 'obs', 'x32', 'encoder', 'hyperdeck', 'propresenter'].forEach((key) => {
          byId(`cfg-${key}-ip`).value = nic.ip;
        });
      }
      byId('cfg-controlApi-ip').value = nic.ip;
      if (requireUniqueIps) {
        setStatus(`Applied NIC ${nic.name} (${nic.ip}) in unique-IP mode: ${subnet}.11-.16. Note: those IPs must exist on this host or fallback will be used.`);
      } else {
        setStatus(`Applied NIC ${nic.name} (${nic.ip}) in host-IP mode (recommended). All devices use ${nic.ip} with unique ports.`);
      }
    }

    function collectDeviceIpsFromForm() {
      const ips = [];
      DEVICE_ONLY_KEYS.forEach((key) => {
        const value = String(byId(`cfg-${key}-ip`)?.value || '').trim();
        if (value) ips.push(value);
      });
      return ips;
    }

    function renderAliasCommands(commands = [], label = '') {
      const pre = byId('alias-commands');
      if (!pre) return;
      const list = Array.isArray(commands) ? commands : [];
      const heading = label ? `${label}\n` : '';
      pre.textContent = list.length ? `${heading}${list.join('\n')}` : '(alias commands appear here after setup/remove)';
    }

    async function manageUniqueAliases(action) {
      const nic = currentNicDetails();
      if (!nic) {
        setStatus('Select a NIC first.');
        return;
      }

      const payload = {
        action,
        nicName: nic.name,
        nicIp: nic.ip,
        nicNetmask: nic.netmask,
        ips: collectDeviceIpsFromForm(),
      };

      const verb = action === 'remove' ? 'Removing' : 'Setting up';
      setStatus(`${verb} unique IP aliases on ${nic.name}...`);
      const result = await api.manageIpAliases(payload);
      renderAliasCommands(result?.commands || [], `${action === 'remove' ? 'Remove' : 'Setup'} commands (${nic.name})`);
      if (!result?.ok) {
        setStatus(`Alias ${action} failed: ${result?.error || 'unknown error'}`);
        return;
      }
      setStatus(result?.summary || 'Alias operation completed.');
    }

    async function setupUniqueAliases() {
      await manageUniqueAliases('add');
    }

    async function removeUniqueAliases() {
      await manageUniqueAliases('remove');
    }

    function collectConfigFromForm() {
      const addresses = {};
      for (const key of ENDPOINT_KEYS) {
        const ip = byId(`cfg-${key}-ip`).value.trim();
        const port = Number(byId(`cfg-${key}-port`).value);
        addresses[key] = { ip, port };
      }

      return {
        addresses,
        allowFallback: byId('cfg-allow-fallback').checked,
        requireUniqueIps: byId('cfg-unique-ips').checked,
        nicName: currentNic()?.name || '',
      };
    }

    function fillConfigForm(config) {
      const addresses = config?.addresses || {};
      for (const key of ENDPOINT_KEYS) {
        byId(`cfg-${key}-ip`).value = addresses[key]?.ip || '';
        byId(`cfg-${key}-port`).value = addresses[key]?.port || '';
      }
      byId('cfg-allow-fallback').checked = !!config?.allowFallback;
      byId('cfg-unique-ips').checked = config?.requireUniqueIps === true;
    }

    function renderLogs(lines) {
      const list = Array.isArray(lines) ? lines : [];
      byId('logs-json').textContent = list.length ? list.join('\n') : '(no logs yet)';
    }

    function safeJson(value) {
      if (value === undefined) return 'undefined';
      if (typeof value === 'string') return value;
      try {
        return JSON.stringify(value);
      } catch {
        return String(value);
      }
    }

    function flattenState(input, prefix = '', out = {}) {
      if (Array.isArray(input)) {
        if (!input.length) {
          if (prefix) out[prefix] = '[]';
          return out;
        }
        input.forEach((item, idx) => {
          const key = prefix ? `${prefix}.${idx}` : String(idx);
          flattenState(item, key, out);
        });
        return out;
      }

      if (input && typeof input === 'object') {
        const keys = Object.keys(input);
        if (!keys.length) {
          if (prefix) out[prefix] = '{}';
          return out;
        }
        keys.forEach((key) => {
          const path = prefix ? `${prefix}.${key}` : key;
          flattenState(input[key], path, out);
        });
        return out;
      }

      out[prefix || 'root'] = safeJson(input);
      return out;
    }

    function compactValue(value, max = 86) {
      const text = String(value ?? '');
      return text.length > max ? `${text.slice(0, max)}...` : text;
    }

    function pushChangeEvent(event) {
      changeEvents.unshift(event);
      while (changeEvents.length > MAX_CHANGE_EVENTS) changeEvents.pop();
    }

    function renderChangeFeed() {
      const summary = byId('change-summary');
      const list = byId('change-list');

      const pausedNote = changeFeedPaused ? ` | feed paused${hiddenChangeCount ? ` (${hiddenChangeCount} hidden)` : ''}` : '';
      summary.textContent = `Tracked fields: ${Object.keys(lastFlatState || {}).length} | Events shown: ${changeEvents.length}${pausedNote}`;

      list.innerHTML = '';
      if (!changeEvents.length) {
        const empty = document.createElement('div');
        empty.className = 'change-empty';
        empty.textContent = 'No changes detected yet.';
        list.appendChild(empty);
        return;
      }

      const frag = document.createDocumentFragment();
      changeEvents.forEach((evt) => {
        const row = document.createElement('div');
        row.className = 'change-row';

        const head = document.createElement('div');
        head.className = 'change-head';

        const path = document.createElement('div');
        path.className = 'change-path';
        path.textContent = evt.path;

        const ts = document.createElement('div');
        ts.className = 'change-time';
        ts.textContent = new Date(evt.ts).toLocaleTimeString();

        head.appendChild(path);
        head.appendChild(ts);

        const vals = document.createElement('div');
        vals.className = 'change-values';

        const before = document.createElement('div');
        before.className = 'before';
        before.textContent = `Before: ${compactValue(evt.from)}`;

        const after = document.createElement('div');
        after.className = 'after';
        after.textContent = `After: ${compactValue(evt.to)}`;

        vals.appendChild(before);
        vals.appendChild(after);

        row.appendChild(head);
        row.appendChild(vals);
        frag.appendChild(row);
      });

      list.appendChild(frag);
    }

    function trackStateChanges(nextState) {
      const nextFlat = flattenState(nextState || {});
      if (!lastFlatState) {
        lastFlatState = nextFlat;
        renderChangeFeed();
        return;
      }

      const changes = [];
      const keys = new Set([...Object.keys(lastFlatState), ...Object.keys(nextFlat)]);
      keys.forEach((key) => {
        const before = lastFlatState[key];
        const after = nextFlat[key];
        if (before !== after) {
          changes.push({ path: key, from: before, to: after, ts: Date.now() });
        }
      });

      lastFlatState = nextFlat;
      if (!changes.length) {
        renderChangeFeed();
        return;
      }

      if (changeFeedPaused) {
        hiddenChangeCount += changes.length;
      } else {
        changes.forEach(pushChangeEvent);
      }
      renderChangeFeed();
    }

    function toggleChangeFeed() {
      changeFeedPaused = !changeFeedPaused;
      const btn = byId('btn-change-pause');
      btn.textContent = changeFeedPaused ? 'Resume Feed' : 'Pause Feed';
      if (!changeFeedPaused) hiddenChangeCount = 0;
      renderChangeFeed();
    }

    function switchDeviceTab(tab) {
      const tabs = ['atem', 'hyperdeck', 'obs', 'x32', 'propresenter'];
      tabs.forEach((name) => {
        byId(`tab-btn-${name}`)?.classList.toggle('active', name === tab);
        byId(`tab-panel-${name}`)?.classList.toggle('active', name === tab);
      });
    }

    function clearChangeFeed() {
      changeEvents.splice(0, changeEvents.length);
      hiddenChangeCount = 0;
      renderChangeFeed();
    }

    function setInputValue(id, value) {
      const el = byId(id);
      if (!el || value === undefined || value === null) return;
      if (document.activeElement === el) return;
      el.value = String(value);
    }

    function setAtemAction(label) {
      const el = byId('atem-live-last-action');
      if (!el) return;
      const ts = new Date().toLocaleTimeString();
      el.textContent = `${label} ${ts}`;
    }

    function pulseLivePad(kind = 'preview') {
      const pad = byId('atem-live-pad');
      if (!pad) return;
      const className = kind === 'program' ? 'program-pulse' : 'preview-pulse';
      pad.classList.remove('program-pulse', 'preview-pulse');
      void pad.offsetWidth;
      pad.classList.add(className);
      setTimeout(() => pad.classList.remove(className), 320);
    }

    function atemSourceLabel(atem, input) {
      const label = atem?.labels?.[String(input)] || atem?.labels?.[input];
      if (label?.shortName) return String(label.shortName).toUpperCase();
      if (label?.longName) return String(label.longName).toUpperCase().slice(0, 8);
      if (input <= 8) return `CAM${input}`;
      return `IN${input}`;
    }

    function renderAtemBuses(atem) {
      const programWrap = byId('atem-program-bus');
      const previewWrap = byId('atem-preview-bus');
      if (!programWrap || !previewWrap) return;

      const labelKeys = Object.keys(atem?.labels || {}).map((n) => Number(n)).filter(Number.isFinite);
      const totalInputs = Math.max(20, ...labelKeys, Number(atem?.programInput) || 1, Number(atem?.previewInput) || 2);
      const programInput = Number(atem?.programInput) || 1;
      const previewInput = Number(atem?.previewInput) || 2;

      const renderRow = (target, isProgramRow) => {
        target.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let input = 1; input <= totalInputs; input += 1) {
          const btn = document.createElement('button');
          btn.className = 'atem-src-btn';
          if (input === programInput) btn.classList.add('program-active');
          if (input === previewInput) btn.classList.add('preview-active');
          btn.innerHTML = `<span class="num">${input}</span><span class="name">${atemSourceLabel(atem, input)}</span>`;
          btn.onclick = () => {
            if (isProgramRow) atemSetProgram(input);
            else atemSetPreview(input);
          };
          frag.appendChild(btn);
        }
        target.appendChild(frag);
      };

      renderRow(programWrap, true);
      renderRow(previewWrap, false);
    }

    function atemTbarPreview() {
      const slider = byId('atem-tbar');
      const readout = byId('atem-tbar-readout');
      if (!slider || !readout) return;
      const pct = Math.max(0, Math.min(100, Number(slider.value) || 0));
      if (pct === 0) {
        readout.textContent = 'T-Bar parked at preview (0%)';
        return;
      }
      if (pct === 100) {
        readout.textContent = 'T-Bar at program (100%)';
        return;
      }
      readout.textContent = `T-Bar in transition (${pct}%)`;
    }

    function runAutoTbarAnimation(durationMs = 650) {
      const slider = byId('atem-tbar');
      if (!slider) return Promise.resolve();
      if (autoTbarTimer) {
        clearInterval(autoTbarTimer);
        autoTbarTimer = null;
      }

      return new Promise((resolve) => {
        const started = Date.now();
        autoTbarTimer = setInterval(() => {
          const elapsed = Date.now() - started;
          const pct = Math.min(100, Math.round((elapsed / durationMs) * 100));
          slider.value = String(pct);
          atemTbarPreview();
          if (pct >= 100) {
            clearInterval(autoTbarTimer);
            autoTbarTimer = null;
            setTimeout(() => {
              slider.value = '0';
              atemTbarPreview();
              resolve();
            }, 180);
          }
        }, 20);
      });
    }

    function renderAtemLive(atem) {
      const program = Number(atem?.programInput) || 1;
      const preview = Number(atem?.previewInput) || 2;
      const style = atem?.transition?.style || 'mix';
      const rate = Number(atem?.transition?.rate) || 25;
      const inTransition = !!atem?.inTransition;
      const recording = !!atem?.recording;

      if (byId('atem-live-program')) byId('atem-live-program').textContent = String(program);
      if (byId('atem-live-preview')) byId('atem-live-preview').textContent = String(preview);
      if (byId('atem-live-transition')) byId('atem-live-transition').textContent = `${style} @ ${rate}`;
      if (byId('atem-chip-pgm')) byId('atem-chip-pgm').textContent = String(program);
      if (byId('atem-chip-pvw')) byId('atem-chip-pvw').textContent = String(preview);

      const statusParts = [];
      statusParts.push(inTransition ? 'in-transition' : 'idle');
      if (recording) statusParts.push('recording');
      if (byId('atem-live-status')) byId('atem-live-status').textContent = statusParts.join(' / ');
    }

    function syncAtemControlInputs(atem) {
      setInputValue('atem-program', Number(atem?.programInput) || 1);
      setInputValue('atem-preview', Number(atem?.previewInput) || 2);
      if (atem?.transition?.style) setInputValue('atem-trans-style', atem.transition.style);
      if (atem?.transition?.rate !== undefined) setInputValue('atem-trans-rate', Number(atem.transition.rate) || 25);
    }

    function initAtemLivePadDrag() {
      const panel = byId('tab-panel-atem');
      const pad = byId('atem-live-pad');
      const handle = byId('atem-live-handle');
      if (!panel || !pad || !handle) return;

      let drag = null;

      handle.addEventListener('pointerdown', (ev) => {
        const panelRect = panel.getBoundingClientRect();
        const padRect = pad.getBoundingClientRect();
        drag = {
          pointerId: ev.pointerId,
          offsetX: ev.clientX - padRect.left,
          offsetY: ev.clientY - padRect.top,
          panelRect,
        };
        handle.setPointerCapture(ev.pointerId);
      });

      handle.addEventListener('pointermove', (ev) => {
        if (!drag || ev.pointerId !== drag.pointerId) return;
        const panelRect = panel.getBoundingClientRect();
        const padRect = pad.getBoundingClientRect();

        let left = ev.clientX - panelRect.left - drag.offsetX;
        let top = ev.clientY - panelRect.top - drag.offsetY;

        const maxLeft = Math.max(0, panelRect.width - padRect.width - 10);
        const maxTop = Math.max(0, panelRect.height - padRect.height - 10);
        left = Math.max(0, Math.min(maxLeft, left));
        top = Math.max(0, Math.min(maxTop, top));

        pad.style.left = `${Math.round(left)}px`;
        pad.style.top = `${Math.round(top)}px`;
      });

      const release = (ev) => {
        if (!drag || ev.pointerId !== drag.pointerId) return;
        handle.releasePointerCapture(ev.pointerId);
        drag = null;
      };

      handle.addEventListener('pointerup', release);
      handle.addEventListener('pointercancel', release);
    }

    function setX32Action(label) {
      const el = byId('x32-live-last-action');
      if (!el) return;
      const ts = new Date().toLocaleTimeString();
      el.textContent = `${label} ${ts}`;
    }

    function x32ClampChannel(n) {
      return Math.max(1, Math.min(32, Number(n) || 1));
    }

    function x32MeterPct(value) {
      return `${Math.max(0, Math.min(100, Math.round((Number(value) || 0) * 100)))}%`;
    }

    function x32MainFaderPreview() {
      const val = Number(byId('x32-main-fader-slider')?.value || 0);
      if (byId('x32-main-fader-readout')) {
        byId('x32-main-fader-readout').textContent = `Main: ${val.toFixed(2)}`;
      }
    }

    function renderX32Console(mixer) {
      const m = mixer || {};
      const channels = m.channels || {};
      const selectedChannel = x32ClampChannel(m.selectedChannel || byId('x32-selected-channel')?.value || 1);
      const selected = channels[String(selectedChannel)] || {};

      if (byId('x32-live-selected')) byId('x32-live-selected').textContent = `CH ${selectedChannel}`;
      if (byId('x32-live-scene')) byId('x32-live-scene').textContent = String(Number(m.scene) || 1);
      if (byId('x32-live-main')) byId('x32-live-main').textContent = Number(m.mainFader || 0).toFixed(2);
      if (byId('x32-live-main-muted')) byId('x32-live-main-muted').textContent = m.mainMuted ? 'ON' : 'OFF';

      setInputValue('x32-selected-channel', selectedChannel);
      setInputValue('x32-selected-label', selected.name || `CH ${selectedChannel}`);
      setInputValue('x32-selected-gain', Number(selected.gainDb || 0));
      setInputValue('x32-selected-pan', Number(selected.pan || 0));
      setInputValue('x32-main-fader-slider', Number(m.mainFader || 0).toFixed(2));
      setInputValue('x32-scene', Number(m.scene) || 1);
      x32MainFaderPreview();

      if (byId('x32-selected-pre')) byId('x32-selected-pre').textContent = x32MeterPct(selected.meterPre);
      if (byId('x32-selected-post')) byId('x32-selected-post').textContent = x32MeterPct(selected.meterPost);

      const muteBtn = byId('x32-selected-mute-btn');
      if (muteBtn) muteBtn.classList.toggle('active', !!selected.muted);
      const soloBtn = byId('x32-selected-solo-btn');
      if (soloBtn) soloBtn.classList.toggle('solo-active', !!selected.solo);

      [1, 9, 17, 25].forEach((start) => {
        const btn = byId(`x32-bank-${start}`);
        if (btn) btn.classList.toggle('active', x32BankStart === start);
      });

      const grid = byId('x32-strip-grid');
      if (!grid) return;
      grid.innerHTML = '';
      const frag = document.createDocumentFragment();

      for (let chNum = x32BankStart; chNum < x32BankStart + 8; chNum += 1) {
        const ch = channels[String(chNum)] || {};
        const strip = document.createElement('div');
        strip.className = 'x32-strip';
        if (selectedChannel === chNum) strip.classList.add('selected');

        const head = document.createElement('div');
        head.className = 'x32-strip-head';
        head.innerHTML = `<span>CH ${chNum}</span><span>${Number(ch.gainDb || 0).toFixed(1)}dB</span>`;

        const name = document.createElement('div');
        name.className = 'x32-strip-name';
        name.textContent = ch.name || `CH ${chNum}`;

        const meters = document.createElement('div');
        meters.className = 'x32-meter-wrap';
        const preCol = document.createElement('div');
        preCol.className = 'x32-meter-col';
        const preFill = document.createElement('div');
        preFill.className = 'x32-meter-fill';
        preFill.style.height = x32MeterPct(ch.meterPre);
        preCol.appendChild(preFill);
        const postCol = document.createElement('div');
        postCol.className = 'x32-meter-col';
        const postFill = document.createElement('div');
        postFill.className = 'x32-meter-fill';
        postFill.style.height = x32MeterPct(ch.meterPost);
        postCol.appendChild(postFill);
        meters.appendChild(preCol);
        meters.appendChild(postCol);

        const fader = document.createElement('input');
        fader.className = 'x32-fader';
        fader.type = 'range';
        fader.min = '0';
        fader.max = '1';
        fader.step = '0.01';
        fader.value = String(Number(ch.fader || 0));

        const faderValue = document.createElement('div');
        faderValue.className = 'x32-value';
        faderValue.textContent = `${Math.round((Number(ch.fader) || 0) * 100)}%`;
        fader.addEventListener('input', () => {
          faderValue.textContent = `${Math.round((Number(fader.value) || 0) * 100)}%`;
        });
        fader.addEventListener('change', () => x32SetChannelFader(chNum, Number(fader.value)));

        const actions = document.createElement('div');
        actions.className = 'x32-mini-actions';
        const selBtn = document.createElement('button');
        selBtn.className = 'alt';
        selBtn.textContent = 'Sel';
        selBtn.onclick = () => x32SelectChannel(chNum);
        const muteBtn = document.createElement('button');
        muteBtn.textContent = 'Mute';
        if (ch.muted) muteBtn.classList.add('active');
        muteBtn.onclick = () => x32ToggleChannelMute(chNum);
        const soloBtn = document.createElement('button');
        soloBtn.className = 'warn';
        soloBtn.textContent = 'Solo';
        if (ch.solo) soloBtn.classList.add('solo-active');
        soloBtn.onclick = () => x32ToggleChannelSolo(chNum);
        const panTag = document.createElement('button');
        panTag.className = 'alt';
        panTag.textContent = `Pan ${Number(ch.pan || 0).toFixed(2)}`;
        panTag.onclick = () => x32SelectChannel(chNum);
        actions.appendChild(selBtn);
        actions.appendChild(muteBtn);
        actions.appendChild(soloBtn);
        actions.appendChild(panTag);

        strip.appendChild(head);
        strip.appendChild(name);
        strip.appendChild(meters);
        strip.appendChild(fader);
        strip.appendChild(faderValue);
        strip.appendChild(actions);
        frag.appendChild(strip);
      }

      grid.appendChild(frag);
    }

    function initX32LivePadDrag() {
      const panel = byId('tab-panel-x32');
      const pad = byId('x32-live-pad');
      const handle = byId('x32-live-handle');
      if (!panel || !pad || !handle) return;

      let drag = null;
      handle.addEventListener('pointerdown', (ev) => {
        const panelRect = panel.getBoundingClientRect();
        const padRect = pad.getBoundingClientRect();
        drag = {
          pointerId: ev.pointerId,
          offsetX: ev.clientX - padRect.left,
          offsetY: ev.clientY - padRect.top,
          panelRect,
        };
        handle.setPointerCapture(ev.pointerId);
      });

      handle.addEventListener('pointermove', (ev) => {
        if (!drag || ev.pointerId !== drag.pointerId) return;
        const panelRect = panel.getBoundingClientRect();
        const padRect = pad.getBoundingClientRect();
        let left = ev.clientX - panelRect.left - drag.offsetX;
        let top = ev.clientY - panelRect.top - drag.offsetY;
        const maxLeft = Math.max(0, panelRect.width - padRect.width - 10);
        const maxTop = Math.max(0, panelRect.height - padRect.height - 10);
        left = Math.max(0, Math.min(maxLeft, left));
        top = Math.max(0, Math.min(maxTop, top));
        pad.style.left = `${Math.round(left)}px`;
        pad.style.top = `${Math.round(top)}px`;
      });

      const release = (ev) => {
        if (!drag || ev.pointerId !== drag.pointerId) return;
        handle.releasePointerCapture(ev.pointerId);
        drag = null;
      };
      handle.addEventListener('pointerup', release);
      handle.addEventListener('pointercancel', release);
    }

    function renderObsOutput(status) {
      const obs = status?.state?.obs || {};
      const mock = obs?.mockOutput || {};
      const controlUrl = status?.controlUrl || '';
      const streamPath = mock.streamPath || '/api/obs/mock-stream.mjpg';
      const graphicPath = mock.graphicPath || '/api/obs/mock-graphic.svg';
      const streamUrl = controlUrl ? `${controlUrl}${streamPath}` : '-';
      const graphicUrl = controlUrl ? `${controlUrl}${graphicPath}` : '-';

      endpointText('obs-mock-stream-url', `Mock Stream: ${streamUrl}`);
      endpointText('obs-mock-graphic-url', `Static Graphic: ${graphicUrl}`);

      const mockState = `OBS ${obs?.streaming ? 'streaming' : 'idle'} | clients: ${Number(mock.clients || 0)} | mock fps: ${Number(mock.fps || 2)} | bytes out: ${Number(mock.bytesOut || 0)}`;
      if (byId('obs-mock-state')) byId('obs-mock-state').textContent = mockState;

      if (mock.title !== undefined) setInputValue('obs-mock-title', mock.title);
      if (mock.subtitle !== undefined) setInputValue('obs-mock-subtitle', mock.subtitle);
      if (mock.fps !== undefined) setInputValue('obs-mock-fps', Number(mock.fps) || 2);
    }

    function renderStatus(s) {
      mockLab = s;
      endpointText('ep-atem', `ATEM: ${s?.addresses?.atem?.ip || '-'}:${s?.addresses?.atem?.port || '-'}`);
      endpointText('ep-obs', `OBS: ${s?.addresses?.obs?.ip || '-'}:${s?.addresses?.obs?.port || '-'}`);
      endpointText('ep-x32', `X32: ${s?.addresses?.x32?.ip || '-'}:${s?.addresses?.x32?.port || '-'}`);
      endpointText('ep-encoder', `Encoder: ${s?.addresses?.encoder?.ip || '-'}:${s?.addresses?.encoder?.port || '-'}`);
      endpointText('ep-hyperdeck', `HyperDeck: ${s?.addresses?.hyperdeck?.ip || '-'}:${s?.addresses?.hyperdeck?.port || '-'}`);
      endpointText('ep-propresenter', `ProPresenter: ${s?.addresses?.propresenter?.ip || '-'}:${s?.addresses?.propresenter?.port || '-'}`);
      endpointText('ep-control', `Control API: ${s?.controlUrl || '-'}`);

      const running = s?.running ? 'RUNNING' : 'STOPPED';
      const fallback = s?.fallbackMode ? ' (fallback active)' : '';
      setStatus(`Lab: ${running}${fallback}`);

      const atem = s?.state?.atem || {};
      renderAtemLive(atem);
      syncAtemControlInputs(atem);
      renderAtemBuses(atem);
      renderX32Console(s?.state?.mixer || {});
      renderObsOutput(s);

      byId('state-json').textContent = JSON.stringify(s?.state || {}, null, 2);
      trackStateChanges(s?.state || {});
      renderLogs(s?.logs || []);
    }

    async function loadConfig() {
      const config = await api.getMockLabConfig();
      await hydrateNetworkInterfaces(config?.nicName || '');
      fillConfigForm(config);
      setStatus('Config loaded. Review IP and port layout before launch.');
      return config;
    }

    async function saveConfig(showMessage = true) {
      const payload = collectConfigFromForm();
      const result = await api.saveMockLabConfig(payload);
      if (showMessage) {
        setStatus('Config saved.');
      }
      return result?.config || payload;
    }

    async function refreshStatus() {
      const s = await api.getMockLabStatus();
      renderStatus(s);
    }

    async function startLab() {
      const config = await saveConfig(false);
      const s = await api.startMockLab(config);
      renderStatus(s);
    }

    async function stopLab() {
      const s = await api.stopMockLab();
      renderStatus(s);
    }

    async function openControlApi() {
      if (!mockLab?.controlUrl) await refreshStatus();
      if (mockLab?.controlUrl) await api.openExternal(mockLab.controlUrl);
    }

    async function post(path, body = {}) {
      if (!mockLab?.controlUrl) await refreshStatus();
      if (!mockLab?.controlUrl) throw new Error('Control API unavailable. Launch lab first.');
      const res = await fetch(`${mockLab.controlUrl}${path}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
      await refreshStatus();
    }

    async function loadCommands() {
      if (!mockLab?.controlUrl) await refreshStatus();
      if (!mockLab?.controlUrl) {
        byId('commands-json').textContent = '[]';
        return;
      }
      const res = await fetch(`${mockLab.controlUrl}/api/commands`);
      const data = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
      byId('commands-json').textContent = JSON.stringify(data?.commands || [], null, 2);
    }

    async function atemSetProgram(input) {
      const value = Math.max(1, Number(input) || 1);
      setInputValue('atem-program', value);
      setAtemAction(`PROGRAM ${value}`);
      pulseLivePad('program');
      await post('/api/program', { input: value });
    }
    async function atemSetPreview(input) {
      const value = Math.max(1, Number(input) || 1);
      setInputValue('atem-preview', value);
      setAtemAction(`PREVIEW ${value}`);
      pulseLivePad('preview');
      await post('/api/preview', { input: value });
    }
    async function atemProgram() { await atemSetProgram(Number(byId('atem-program').value)); }
    async function atemPreview() { await atemSetPreview(Number(byId('atem-preview').value)); }
    async function atemCut() {
      setAtemAction('CUT');
      pulseLivePad('program');
      await post('/api/cut');
      const slider = byId('atem-tbar');
      if (slider) {
        slider.value = '100';
        atemTbarPreview();
        setTimeout(() => {
          slider.value = '0';
          atemTbarPreview();
        }, 120);
      }
    }
    async function atemAuto() {
      setAtemAction('AUTO');
      pulseLivePad('preview');
      runAutoTbarAnimation().catch(() => {});
      await post('/api/auto');
      setTimeout(() => refreshStatus().catch(() => {}), 650);
    }
    async function atemRec(v) { await post('/api/recording', { recording: !!v }); }
    async function atemFade(v) {
      setAtemAction(v ? 'FTB ON' : 'FTB OFF');
      await post('/api/fade-to-black', { enabled: !!v });
    }
    async function atemTransition() {
      await post('/api/atem/transition/style', {
        style: byId('atem-trans-style').value,
      });
      await post('/api/atem/transition/rate', {
        rate: Number(byId('atem-trans-rate').value),
      });
    }
    async function atemAux() {
      await post('/api/atem/aux', {
        aux: Number(byId('atem-aux-bus').value),
        input: Number(byId('atem-aux-input').value),
      });
    }
    async function atemUskType() {
      await post('/api/atem/usk/type', {
        keyer: Number(byId('atem-usk-keyer').value),
        type: byId('atem-usk-type').value,
      });
    }
    async function atemUskSources() {
      await post('/api/atem/usk/sources', {
        keyer: Number(byId('atem-usk-keyer').value),
        fillSource: Number(byId('atem-usk-fill').value),
        keySource: Number(byId('atem-usk-key').value),
      });
    }
    async function atemUskOnAir(v) {
      await post('/api/atem/usk/onair', {
        keyer: Number(byId('atem-usk-keyer').value),
        onAir: !!v,
      });
    }
    async function atemUskTie() {
      const keyer = Number(byId('atem-usk-keyer').value);
      const current = !!mockLab?.state?.atem?.upstreamKeyers?.[keyer]?.tie;
      await post('/api/atem/usk/tie', {
        keyer,
        tie: !current,
      });
    }
    async function atemDskRate() {
      await post('/api/atem/dsk/rate', {
        keyer: Number(byId('atem-dsk-keyer').value),
        rate: Number(byId('atem-dsk-rate').value),
      });
    }
    async function atemDskSource() {
      await post('/api/atem/dsk/source', {
        keyer: Number(byId('atem-dsk-keyer').value),
        fillSource: Number(byId('atem-dsk-fill').value),
        keySource: Number(byId('atem-dsk-key').value),
      });
    }
    async function atemDskOnAir(v) {
      await post('/api/atem/dsk/onair', {
        keyer: Number(byId('atem-dsk-keyer').value),
        onAir: !!v,
      });
    }
    async function atemDskTie() {
      const keyer = Number(byId('atem-dsk-keyer').value);
      const current = !!mockLab?.state?.atem?.downstreamKeyers?.[keyer]?.tie;
      await post('/api/atem/dsk/tie', {
        keyer,
        tie: !current,
      });
    }
    async function atemSuperSourceBox(enabled) {
      await post('/api/atem/supersource/box', {
        box: Number(byId('atem-ss-box').value),
        enabled: !!enabled,
        input: Number(byId('atem-ss-input').value),
        x: Number(byId('atem-ss-x').value),
        y: Number(byId('atem-ss-y').value),
        size: Number(byId('atem-ss-size').value),
        cropped: !!byId('atem-ss-cropped')?.checked,
      });
    }
    async function atemSuperSourceArt(enabled) {
      await post('/api/atem/supersource/art', {
        enabled: !!enabled,
        fillSource: Number(byId('atem-ss-fill').value),
        cutSource: Number(byId('atem-ss-cut').value),
        clip: Number(byId('atem-ss-clip').value),
        gain: Number(byId('atem-ss-gain').value),
        premultiplied: !!byId('atem-ss-premultiplied')?.checked,
        invert: !!byId('atem-ss-invert')?.checked,
      });
    }
    async function atemColor() {
      await post('/api/atem/color', {
        index: Number(byId('atem-color-index').value),
        hue: Number(byId('atem-color-hue').value),
        saturation: Number(byId('atem-color-saturation').value),
        luma: Number(byId('atem-color-luma').value),
      });
    }
    async function atemMacroRun() {
      await post('/api/atem/macro/run', {
        index: Number(byId('atem-macro-index').value),
      });
    }
    async function atemMacroStop() {
      await post('/api/atem/macro/stop', {});
    }
    async function atemMediaSource() {
      await post('/api/atem/media/source', {
        player: Number(byId('atem-media-player').value),
        sourceType: byId('atem-media-type').value,
        sourceIndex: Number(byId('atem-media-index').value),
      });
    }
    async function atemMediaPlay(v) {
      await post('/api/atem/media/play', {
        player: Number(byId('atem-media-player').value),
        playing: !!v,
      });
    }
    async function atemLabel() {
      await post('/api/atem/label', {
        input: Number(byId('atem-label-input').value),
        longName: byId('atem-label-name').value,
        shortName: byId('atem-label-short').value,
      });
    }
    async function atemPtzPreset() {
      await post('/api/atem/ptz/preset', {
        camera: Number(byId('atem-ptz-camera').value),
        preset: Number(byId('atem-ptz-preset').value),
      });
    }
    async function atemPtzPanTilt() {
      await post('/api/atem/ptz/pantilt', {
        camera: Number(byId('atem-ptz-camera').value),
        pan: Number(byId('atem-ptz-pan').value),
        tilt: Number(byId('atem-ptz-tilt').value),
      });
    }
    async function atemPtzZoom() {
      await post('/api/atem/ptz/zoom', {
        camera: Number(byId('atem-ptz-camera').value),
        zoom: Number(byId('atem-ptz-zoom').value),
      });
    }
    async function hyperdeckAction() {
      await post('/api/hyperdeck/action', {
        index: Number(byId('hd-index').value),
        action: byId('hd-action').value,
      });
    }

    async function obsStream(v) { await post('/api/obs/stream', { active: !!v }); }
    async function obsRecord(v) { await post('/api/obs/record', { active: !!v }); }
    async function obsScene() { await post('/api/obs/scene', { scene: byId('obs-scene').value }); }
    async function encoderApply() {
      await post('/api/obs/encoder', {
        fps: Number(byId('enc-fps').value),
        cpuUsage: Number(byId('enc-cpu').value),
        congestion: Number(byId('enc-cong').value),
        bitrateKbps: Number(byId('enc-kbps').value),
      });
    }
    async function obsMockGraphicApply() {
      await post('/api/obs/mock-graphic', {
        title: byId('obs-mock-title').value,
        subtitle: byId('obs-mock-subtitle').value,
        fps: Number(byId('obs-mock-fps').value),
      });
    }
    async function openObsMockStream() {
      if (!mockLab?.controlUrl) await refreshStatus();
      const path = mockLab?.state?.obs?.mockOutput?.streamPath || '/api/obs/mock-stream.mjpg';
      if (mockLab?.controlUrl) await api.openExternal(`${mockLab.controlUrl}${path}`);
    }
    async function openObsMockGraphic() {
      if (!mockLab?.controlUrl) await refreshStatus();
      const path = mockLab?.state?.obs?.mockOutput?.graphicPath || '/api/obs/mock-graphic.svg';
      if (mockLab?.controlUrl) await api.openExternal(`${mockLab.controlUrl}${path}`);
    }

    async function x32SetBank(start) {
      x32BankStart = [1, 9, 17, 25].includes(Number(start)) ? Number(start) : 1;
      renderX32Console(mockLab?.state?.mixer || {});
    }

    async function x32SelectChannel(channel) {
      const ch = x32ClampChannel(channel);
      setX32Action(`SELECT CH ${ch}`);
      await post('/api/mixer/channel/select', { channel: ch });
    }

    async function x32SelectChannelFromInput() {
      await x32SelectChannel(byId('x32-selected-channel')?.value);
    }

    async function x32SetChannelFader(channel, level) {
      const ch = x32ClampChannel(channel);
      const v = Math.max(0, Math.min(1, Number(level) || 0));
      setX32Action(`CH ${ch} FADER ${Math.round(v * 100)}%`);
      await post('/api/mixer/channel/fader', { channel: ch, level: v });
    }

    async function x32ToggleChannelMute(channel) {
      const ch = x32ClampChannel(channel);
      const current = !!mockLab?.state?.mixer?.channels?.[String(ch)]?.muted;
      setX32Action(`CH ${ch} ${current ? 'UNMUTE' : 'MUTE'}`);
      await post('/api/mixer/channel/mute', { channel: ch, muted: !current });
    }

    async function x32ToggleChannelSolo(channel) {
      const ch = x32ClampChannel(channel);
      const current = !!mockLab?.state?.mixer?.channels?.[String(ch)]?.solo;
      setX32Action(`CH ${ch} ${current ? 'SOLO OFF' : 'SOLO ON'}`);
      await post('/api/mixer/channel/solo', { channel: ch, solo: !current });
    }

    async function x32SetSelectedGain() {
      const ch = x32ClampChannel(byId('x32-selected-channel')?.value);
      const gainDb = Number(byId('x32-selected-gain')?.value || 0);
      setX32Action(`CH ${ch} GAIN ${gainDb.toFixed(1)}dB`);
      await post('/api/mixer/channel/gain', { channel: ch, gainDb });
    }

    async function x32SetSelectedPan() {
      const ch = x32ClampChannel(byId('x32-selected-channel')?.value);
      const pan = Number(byId('x32-selected-pan')?.value || 0);
      setX32Action(`CH ${ch} PAN ${pan.toFixed(2)}`);
      await post('/api/mixer/channel/pan', { channel: ch, pan });
    }

    async function x32RenameSelected() {
      const ch = x32ClampChannel(byId('x32-selected-channel')?.value);
      const name = String(byId('x32-selected-label')?.value || '').trim();
      setX32Action(`CH ${ch} LABEL`);
      await post('/api/mixer/channel/label', { channel: ch, name });
    }

    async function x32ToggleSelectedMute() {
      await x32ToggleChannelMute(byId('x32-selected-channel')?.value);
    }

    async function x32ToggleSelectedSolo() {
      await x32ToggleChannelSolo(byId('x32-selected-channel')?.value);
    }

    async function x32SetMainFader() {
      const level = Math.max(0, Math.min(1, Number(byId('x32-main-fader-slider')?.value || 0)));
      setX32Action(`MAIN ${Math.round(level * 100)}%`);
      await post('/api/mixer/fader', { level });
    }

    async function x32Mute(v) {
      setX32Action(v ? 'MAIN MUTE ON' : 'MAIN MUTE OFF');
      await post('/api/mixer/master', { muted: !!v });
    }

    async function x32Scene() {
      const scene = Math.max(1, Number(byId('x32-scene')?.value || 1));
      setX32Action(`SCENE ${scene}`);
      await post('/api/mixer/scene', { scene });
    }

    async function ppNext() { await post('/api/propresenter/next'); }
    async function ppPrev() { await post('/api/propresenter/prev'); }
    async function ppGo() { await post('/api/propresenter/slide', { index: Number(byId('pp-slide').value) - 1 }); }

    async function resetAll() { await post('/api/reset', {}); }

    function wireLogStream() {
      api.onMockLabLog((line) => {
        const pre = byId('logs-json');
        const current = pre.textContent === '(waiting for logs)' ? [] : pre.textContent.split('\n');
        current.push(line);
        while (current.length > 180) current.shift();
        pre.textContent = current.join('\n');
      });
    }

    async function init() {
      wireLogStream();
      switchDeviceTab('atem');
      initAtemLivePadDrag();
      initX32LivePadDrag();
      atemTbarPreview();
      x32MainFaderPreview();
      await loadConfig();
      await refreshStatus();
      refreshTicker = setInterval(() => refreshStatus().catch(() => {}), 2500);
    }

    init().catch((e) => {
      setStatus(`Failed to initialize: ${e.message}`);
    });
  </script>
</body>
</html>
